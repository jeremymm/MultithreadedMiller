//***************************************************************************//
// Timer Implementation
//
// Created May 14, 2005
// By: Jeremy Michael Miller
//
// Copyright (c) 2005-2016 Jeremy Michael Miller. 
// Author: = "Jeremy Michael Miller"
// Copyright: = "Copyright 2006-2016, Multithreaded Miller,  All rights reserved."
// Credits = ["Jeremy Michael Miller"]
// License: "Fair use v0.9"
// Version: "0.0.1"
// Maintainer: "Jeremy Michael Miller"
// Email: "maybe_later@mst.dnsalias.net"
// Status: "Alpha"
//***************************************************************************//

//***************************************************************************//
// System Includes
#include <assert.h>
#ifdef WINDOWS_THREADS
#include <windows.h>
#endif WINDOWS_THREADS
//***************************************************************************//

//***************************************************************************//
// Local Includes
#include "Timer.hpp"
//***************************************************************************//

//***************************************************************************//
namespace MST
{
  //-------------------------------------------------------------------------//
  Timer::Timer()
  {
    //-----------------------------------------------------------------------//
    long long llClockRate  = 0;
    long long llStartClock = 0;
    mdInverseClockRate     = 0.0;
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&llClockRate));
    assert(llClockRate);
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    mdInverseClockRate = 1.0/static_cast<double>(llClockRate);
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&llStartClock));
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    for(unsigned long i = 0; i < NUMBER_OF_TIMERS; i++)
    {
      mllStartClocks[i] = llStartClock;
    }
    //-----------------------------------------------------------------------//
  }
  //-------------------------------------------------------------------------//

  //-------------------------------------------------------------------------//
  Timer::~Timer()
  {
  }
  //-------------------------------------------------------------------------//

  //-------------------------------------------------------------------------//
  double Timer::DT(enum Timers eTimer)
  {
    //-----------------------------------------------------------------------//
    double dResult = 0.0;
    long long llEndClock = 0;
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    if(QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&llEndClock)))
    {
      dResult = (llEndClock - mllStartClocks[eTimer])*mdInverseClockRate;
      mllStartClocks[eTimer] = llEndClock;
    }
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    return dResult;
    //-----------------------------------------------------------------------//
  } // End of double Timer::DT(enum Timers eTimer)
  //-------------------------------------------------------------------------//

  //-------------------------------------------------------------------------//
  double Timer::ET(enum Timers eTimer)
  {
    //-----------------------------------------------------------------------//
    double dResult = 0.0;
    long long llEndClock = 0;
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    if(QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&llEndClock)))
    {
      dResult = (llEndClock - mllStartClocks[eTimer])*mdInverseClockRate;
    }
    //-----------------------------------------------------------------------//

    //-----------------------------------------------------------------------//
    return dResult;
    //-----------------------------------------------------------------------//
  } // End of double Timer::ET(enum Timers eTimer)
  //-------------------------------------------------------------------------//
} // End of namespace MST
//***************************************************************************//
